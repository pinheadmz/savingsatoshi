# Chapter 5 challenge outline



1. Vanderpoole says he signed a message with Satoshi's keys:

```
-----BEGIN BITCOIN SIGNED MESSAGE-----

I am Vanderpoole and I have control of the private key Satoshi
used to sign the first-ever Bitcoin transaction confirmed in block #170.
This message is signed with the same private key.

-----BEGIN BITCOIN SIGNATURE-----

IIXCUGj6YMEAIBlD5RCWJBTu6mKggy0LmtgPwATZIolecTE6JPrP0nEynAPDIPtLXZ1vWMUYBnRChCUXNT2nw3o=

-----END BITCOIN SIGNATURE----- 
```

What does this even mean?

We learned in chapter 4 that private keys are huge random numbers kept secret by whomever
generated them. We can use Elliptic Curve math to derive a public key from that private key.
The public key can be shared as a unique identifier and the private key is used to 
**prove** a person has control of that identifier. That proof is called a SIGNATURE.
To create a signature you need a message and a private key. Anyone can verify the
signature with a copy of the message and the corresponding public key.

Vanderpoole has provided a signature and a message. Where is the public key?



2. Find Satoshi's public key

Hal Finney claimed Satoshi sent him the first Bitcoin transaction ever, confirmed in block #170:
https://bitcointalk.org/index.php?topic=155054.0

That transaction can be found on a block explorer here:
https://blockstream.info/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16?expand

In the `scriptSig` of input #0 there is a chunk of data beginning with `30...`
find it and copy/paste here:

[ 3044... ... ... ... ]

This is actually Satoshis signature, authorizing the transfer of his Bitcoin to Hal Finney.

**So where is his public key?**
It's actually stored along with the Bitcoin Satoshi generated by mining block #9.
Follow the link to the source transaction at the top of the input #0 section:
https://blockstream.info/tx/0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9?output:0&expand

This is the transaction Satoshi created by mining block #9. The transaction creates 50 BTC
and locks them under control of... a public key! Find the data beginning with `04...` in
the `scriptPubKey`. The public key lives between the script commands `OP_PUSHBYTES` and `OP_CHECKSIG`.
Copy/paste it here:

[ 0411... ... ... ... ]

So Satoshi created a transaction that sent 50 BTC to his public key. Then he used
his private key to create a signature that transferred 10 of those BTC to Hal Finney's
public key. Next we need to learn how to verify a signature. But something is still
missing... what is the **message** Satoshi signed to authorize the transaction for Hal?



3. Derive the message from the transaction pt. 1

It should be clear by just looking at the block explorer web page that a Bitcoin
transaction has many different parts. Some parts are just small numbers and some
parts are larger chunks of data. The Bitcoin protocol has a very specific algorithm
for creating messages from transactions, so those messages can be signed by private keys.

We will summarize the process outlined in https://en.bitcoin.it/wiki/OP_CHECKSIG#How_it_works
which conveniently uses this exact same transaction as an example: https://en.bitcoin.it/wiki/OP_CHECKSIG#Code_samples_and_raw_dumps

To begin, we need the raw bytes that make up the complete transaction. Our block
explorer can help with this. Use the "hex" API endpoint below and copy/paste the
entire blob of data here:

https://blockstream.info/api/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16/hex

[ 0100... ... ... ]

```
/**
 * MAGIC!!!!
 * When the user pastes the blob of data we can sort it for them on the right
 * side of the screen. It would be really awesome if there was some kind of
 * color-coding so they can see how the blob they pasted is a serialization
 * of all the different fields.
 */
```

This is the raw transaction with each component labeled:
```
    version:
     01000000
    number of inputs:
     01
    hash of tx being spent by input #0:
     c997a5e56e104102fa209c6a852dd90660a20b2d9c352423edce25857fcd3704
    index of output of tx being spent by input #0:
     00000000
    scriptSig to authorize spending the indicated output:
     4847304402204e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c615
     48ab5fb8cd410220181522ec8eca07de4860a4acdd12909d831cc56cbbac4622
     082221a8768d1d0901
    input #0 sequence:
     ffffffff
    number of outputs:
     02
    output #0 value (10 BTC or 1,000,000,000 satoshis):
     00ca9a3b00000000
    output #0 scriptPubKey (Hal Finney's public key plus OP_CHECKSIG):
     434104ae1a62fe09c5f51b13905f07f06b99a2f7159b2225f374cd378d71302f
     a28414e7aab37397f554a7df5f142c21c1b7303b8a0626f1baded5c72a704f7e
     6cd84cac
    outut #1 value (40 BTC or 4,000,000,000 satoshis):
     00286bee00000000
    output #1 scriptPubKey (Satoshi's oen public key again, for change):
     43410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6
     909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656
     b412a3ac
    locktime:
     00000000
```



4. Derive the message from the transaction pt. 2

It's impossible to sign a message containing it's own signature, so the scriptSig
needs to be removed. In the Bitcoin protocol it is actually replaced by the
scriptPubKey of the transaction output we are spending. We already found the
scriptPubKey back in step 2, you can paste that in the blank.

(chart doesn't need to be colored anymore, now it is actually a python script)

```python
msg = ""

# version:
msg += "01000000"

# number of inputs:
msg += "01"

# hash of tx being spent by input #0:
msg += "c997a5e56e104102fa209c6a852dd90660a20b2d9c352423edce25857fcd3704"

# index of output of tx being spent by input #0:
msg += "00000000"

# scriptPubKey of output being spent by input #0:
# FILL IN THIS LINE!

# input #0 sequence:
msg += "ffffffff"

# number of outputs:
msg += "02"

# output #0 value (10 BTC or 1,000,000,000 satoshis):
msg += "00ca9a3b00000000"

# output #0 scriptPubKey (Hal Finney's public key plus OP_CHECKSIG):
msg += "434104ae1a62fe09c5f51b13905f07f06b99a2f7159b2225f374cd378d71302f"
msg += "a28414e7aab37397f554a7df5f142c21c1b7303b8a0626f1baded5c72a704f7e"
msg += "6cd84cac"

# outut #1 value (40 BTC or 4,000,000,000 satoshis):
msg += "00286bee00000000"

# output #1 scriptPubKey (Satoshi's oen public key again, for change):
msg += "43410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6"
msg += "909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656"
msg += "b412a3ac"

# locktime:
msg += "00000000"

# SIGHASH FLAG GOES HERE!
```

The last thing we need for our transaction message is a "sighash type flag".
We'll cover this more in the next chapter but for now we'll just add the value
`01000000` to the end of the message.


```
  (ANSWER:)
    0100000001c997a5e56e104102fa209c6a852dd90660a20b2d9c352423edce25
    857fcd37040000000043410411db93e1dcdb8a016b49840f8c53bc1eb68a382e
    97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9
    d4c03f999b8643f656b412a3acffffffff0200ca9a3b00000000434104ae1a62
    fe09c5f51b13905f07f06b99a2f7159b2225f374cd378d71302fa28414e7aab3
    7397f554a7df5f142c21c1b7303b8a0626f1baded5c72a704f7e6cd84cac0028
    6bee0000000043410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b148
    2ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f
    999b8643f656b412a3ac0000000001000000
```

(success message):
Finally we have a message! We also have a signature we know Satoshi created
with his own private keys, and we have his public key. Let's learn how to verify
the signature and then we can try to verify Vanderpoole's signature.



5. Hash the transaction digest

The serialized transaction data we compiled in the last step is actually too
long to sign or verify with ECDSA. Do we know any way to compress large chunks of
data into more consistent, manageable pieces? We sure do: hashing. The Bitcoin
protocol uses a double SHA256 digest to compress a transaction into a
signable message. Once we have a 32 byte hash, that data is re-interpreted as
an integer. Yes, a 32-byte integer (that is a truly enormous number)!

```
/**
 * CODING CHALLENGE
 * double hash the blob we pasted in the last step and convert to integer
 */
```

Example answer in python:
```python
import hashlib
from lib.secp256k1 import GE, G

# Serialized tx data from step 3
data = """0100000001c997a5e56e104102fa209c6a852dd90660a20b2d9c352423edce25
          857fcd37040000000043410411db93e1dcdb8a016b49840f8c53bc1eb68a382e
          97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9
          d4c03f999b8643f656b412a3acffffffff0200ca9a3b00000000434104ae1a62
          fe09c5f51b13905f07f06b99a2f7159b2225f374cd378d71302fa28414e7aab3
          7397f554a7df5f142c21c1b7303b8a0626f1baded5c72a704f7e6cd84cac0028
          6bee0000000043410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b148
          2ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f
          999b8643f656b412a3ac0000000001000000"""

# Double-SHA256 the tx data
single_hash = hashlib.new('sha256', bytes.fromhex(data)).digest()
double_hash = hashlib.new('sha256', single_hash).digest()

# Convert the hash to a 32-byte integer
msg = int.from_bytes(double_hash)
```



6. Decode the signature

Satoshi's signature is encoded in a system called DER which is a subset of ASN.1
https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/

There are two 32-byte numbers we need to extract. They are referred to as `R` and `S`
respectively and are each prefixed by the bytes `0220` in the DER sequence. Instead
of fully decoding the DER blob, just look for the prefixes and copy/paste the `R` and
`S` values below

R: [ ... ]
S: [ ... ]

(answer)
```
# Satoshi's signature, from the input scriptSig of the tx to Hal Finney
sig_der = """304402204e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab
             5fb8cd410220181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082
             221a8768d1d09"""

# Extract the two 32-byte values (r, s) from the DER-encoded signature
sig_r = 0x4e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd41
sig_s = 0x181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d09

```



7. Decode the public key

We learned in chapter 4 that public keys are really points in the ECDSA curve,
meaning they have an x and y value. The first byte `04` means "uncompressed"
(as opposed to `02` and `03` like we learned in chapter 4). Remove that first
byte and the remaining data are 32-byte x and y coordinates. Copy/paste below.

X: [ ... ]
Y: [ ... ]

(answer)
```

# Satoshi's public key, from the block 9 coinbase output scriptPubKey
pubkey = """0411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a
            5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412
            a3"""

# Extract the two 32-byte values (x, y) from the key and create a ECDSA point
pubkey_x = 0x11db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5c
pubkey_y = 0xb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3
```


8. Verify the signature!

At this point we have everything we need to do some ECDSA math:

```python
# Signature:
sig_r = 0x4e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd41
sig_s = 0x181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d09

# Public Key:
pubkey_x = 0x11db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5c
pubkey_y = 0xb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3

# Message digest:
msg = 0x7a05c6145f10101e9d6325494245adf1297d80f8f38d4d576d57cdba220bcb19
```

The ECDSA signature verification algorithm is explained here:
https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Signature_verification_algorithm
and here (Go to page 46, section 4.1.4):
https://www.secg.org/sec1-v2.pdf

You will need to create a Group Element object from the public key X and Y elements
and then execute the ECDSA function:

(answer)
```python
from lib.secp256k1 import GE
key_ge = GE(pubkey_x, pubkey_y)
```

```python
from lib.secp256k1 import GE, G

if sig_r == 0 or sig_r >= GE.ORDER:
  print("FALSE - invalid r value")

if sig_s == 0 or sig_s >= GE.ORDER:
  print("FALSE - invalid s value")

sig_s_inverted = pow(sig_s, -1, GE.ORDER)
u1 = (msg * sig_s_inverted) % GE.ORDER
u2 = (sig_r * sig_s_inverted) % GE.ORDER
R = (u1 * G) + (u2 * key_ge)

if sig_r == int(R.x):
  print("TRUE - valid signature")
else:
  print("FALSE - invalid signature")
```

We know Satoshi's signature is valid, it has been checked by every Bitcoin full
node since 2010! If your program does not return "true" something is wrong.
